\chapter{Evaluation}
\label{ch:evaluation}
\section{Criteria of Assessment}
For evaluation of this project, we consider our aims and objectives as discussed in the introduction, amongst other considerations from . Deriving from these objectives, we can determine a set of criteria that we can base our evaluation upon:

Accuracy - The system is capable of producing accurate outputs for the stoichiometries and precursors that a user may desire.
Relevancy - The system produces results that are suitably relevant to the user without too many “garbage” results, or at least orders results by relevance.
Speed - The system returns its results in a reasonable amount of time.

\subsection{Accuracy}
In the interests of evaluating accuracy, we took known, preexisting stoichiometries and precursor calculations from publicly available sources and used them to ensure that the program was calculating its outputs correctly. By taking a suitably sized collection of pre-calculated values, we repeatedly tested the system using inputs designed to acquire these values, using any failed cases to re-evaluate what went wrong and adjust the system accordingly. 

After more thorough testing of a multitude of precursor and stoichiometry combinations, we have concluded that the program is accurate to a suitable degree in most cases. As mentioned previously in the design section, we did remove uncommon charge balances from the calculation in the interest of avoiding untenable combinations as implemented in our current release, so some possible stoichiometries will not be generated. Nevertheless, the outputs the system does generate are in general perfectly viable and correct, and functionality for the rarer charges may be added in future releases.

\subsection{Relevancy}
The system produces a range of stoichiometries based on the user input, presented in a list. As the user goes down this list, the size and composition of these stoichiometries becomes increasingly excessive and unwieldy, and for the most part we expect that only a small selection of optimal results would ever be used by the end user, with the other results only being used in the interests of further analysis and pure curiosity.

By giving the user control of the scope of the results returned to them, both in terms of the maximum mass of the given stoichiometries and the maximum number of results generated, the user can refine their search such that while the system calculates (or retrieves from the database) many potential results, it will only display those results that fit the user’s defined criteria. As such, the user can tailor the relevancy of the results to their liking. In addition, by ranking the results based according to our defined criteria of suitability and displaying them in that order, we ensure that the first few results in the list are likely the most desirable and relevant to the user.

In summary, the program maintains relevant results by empowering the user to more strictly control the results they receive, while allowing them to view the full data set if they so desire. The results produced nearer the top of the list are, in general, the smallest possible stoichiometries form-able from the selected precursors, though in some cases stoichiometries are generated without every desired precursor included. This is minimal issue, however, since enough data is generated that a user can simply ignore these and pick out the stoichiometries that fulfil their needs exactly.

\subsection{Speed}
In earlier versions of the program, the calculator speed varied greatly, with certain calculations taking an unreasonably long time. Given that a user may become impatient if they are made to wait for even a simple stoichiometry calculation, a number of approaches were considered to address the issue. Initially, we considered simply including a loading screen when the user requests a calculation to reassure the user that the system is working, but a more intuitive solution was sought to actually cut down the run time.

In our original implementation, the calculators used a method whereby they calculated every possible combination of elements - with each element proportion measured as a real number from 0 to 1, the program would incrementally run through the combinations in very small margins (approx. 10-3). The program would then need to evaluate and 

The resultant cache file generated by calculations under this method ranged in size between 30 to 100 megabytes, which is unacceptable for common use. The speed of the system was equally unacceptable - Analysis of the run time on a function-by-function basis revealed that almost half of the run time was being taken up by generating weights for each stoichiometry and by validation checks. In  Attempts at optimisation of this method could only result in an approximately 33\% increase in program speed.

In our final implementation, we adjusted the system to run on a much smaller set of real numbers, tying the number generated to the number of results requested by the user. In this method, we generate only as many results as the user wants rather than generating every possible result and then checking to see which of them fits the user criteria.

For a user requesting 1000 samples, the new method generates only 34 numbers to run evaluation on where the previous method would generate over 104 numbers, which results in far less validation runs being needed. As to the overall speed, in a set of tests utilising the same amount of precursors and stoichiometries, the original method completed computation in approx. 2.67 seconds, while the final method completed in just over 0.02 seconds, representing a $13,330\%$ increase in speed. This significant improvement was accepted as more than sufficient for our needs.